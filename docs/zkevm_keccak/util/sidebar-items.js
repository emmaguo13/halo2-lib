window.SIDEBAR_ITEMS = {"constant":[["ABSORB_WIDTH_PER_ROW",""],["ABSORB_WIDTH_PER_ROW_BYTES",""],["BIT_COUNT",""],["BIT_SIZE",""],["KECCAK_WIDTH",""],["KECCAK_WIDTH_IN_BITS",""],["NUM_BITS_PER_BYTE",""],["NUM_BITS_PER_WORD",""],["NUM_BYTES_PER_WORD",""],["NUM_BYTES_TO_ABSORB",""],["NUM_BYTES_TO_SQUEEZE",""],["NUM_ROUNDS",""],["NUM_WORDS_TO_ABSORB",""],["NUM_WORDS_TO_SQUEEZE",""],["RATE",""],["RATE_IN_BITS",""]],"fn":[["field_xor","Calculates a ^ b with a and b field elements"],["get_absorb_positions","The words that absorb data"],["get_degree","Get the degree of the circuit from the KECCAK_DEGREE env variable"],["get_num_bits_per_lookup","Returns how many bits we can process in a single lookup given the range of values the bit can have and the height of the circuit."],["get_rotate_count","Gets the rotation count in parts"],["into_bits","Converts bytes into bits"],["pack","Pack bits in the range [0,BIT_SIZE[ into a sparse keccak word"],["pack_part","Decodes the bits using the position data found in the part info"],["pack_u64","Pack bits stored in a u64 value into a sparse keccak word"],["pack_with_base","Pack bits in the range [0,BIT_SIZE[ into a sparse keccak word with the specified bit base"],["rotate","Rotates a word that was split into parts to the right"],["rotate_left","Rotates bits left"],["rotate_rev","Rotates a word that was split into parts to the left"],["target_part_sizes","Returns the size (in bits) of each part size when splitting up a keccak word in parts of `part_size`"],["unpack","Unpack a sparse keccak word into bits in the range [0,BIT_SIZE["]],"mod":[["constraint_builder",""],["eth_types","Ethereum and Evm types used to deserialize responses from web3 / geth."],["expression",""],["scatter","Scatters a value into a packed word constant"],["to_bytes","Packs bits into bytes"]],"struct":[["PartInfo","Description of which bits (positions) a part contains"],["WordParts","Description of how a word is split into parts"]]};